## 2. Module de logique de jeu (`game_logic.py`)

Ce module encapsule toutes les règles du jeu et fournit l'interface pour manipuler l'état du plateau indépendamment de l'affichage.

### Fonctionnement détaillé

1. **Création et initialisation du plateau**:
    
    python
    
    ```python
    def init_board():
        # Création d'une matrice 7x6 (colonnes x lignes)
        # Chaque case est initialisée à 0 (vide)
        return numpy.zeros((utils.COLUMNS, utils.ROWS), dtype=int)
    ```
    
2. **Validation et placement des jetons**:
    
    python
    
    ```python
    def is_valid_move(board, column):
        # Vérification que la colonne est dans les limites du plateau
        if column < 0 or column >= utils.COLUMNS:
            return False
        # Vérification que la colonne n'est pas pleine
        return board[column][0] == 0
        
    def place_token(board, column, player):
        if not is_valid_move(board, column):
            return None
            
        # Recherche de la position la plus basse disponible
        for row in range(utils.ROWS - 1, -1, -1):
            if board[column][row] == 0:
                board[column][row] = player
                return (column, row)
        
        return None  # Ne devrait jamais arriver si is_valid_move a été vérifié
    ```
    
3. **Identification des coups possibles**:
    
    python
    
    ```python
    def get_valid_columns(board):
        valid_columns = []
        for column in range(utils.COLUMNS):
            if is_valid_move(board, column):
                valid_columns.append(column)
        return valid_columns
    ```
    
4. **Vérification des alignements horizontaux**:
    
    python
    
    ```python
    def check_horizontal(board, last_pos, player):
        column, row = last_pos
        count = 0
        start_col = max(0, column - 3)
        end_col = min(utils.COLUMNS - 1, column + 3)
        
        # Création de la liste des jetons alignés
        aligned_tokens = []
        
        for col in range(start_col, end_col + 1):
            if board[col][row] == player:
                count += 1
                aligned_tokens.append((col, row))
                if count >= 4:
                    return aligned_tokens[-4:]  # Retourne les 4 derniers jetons
            else:
                count = 0
                aligned_tokens = []
        
        return None
    ```
    
5. **Vérification des alignements verticaux**:
    
    python
    
    ```python
    def check_vertical(board, last_pos, player):
        column, row = last_pos
        count = 0
        start_row = max(0, row - 3)
        end_row = min(utils.ROWS - 1, row + 3)
        
        aligned_tokens = []
        
        for r in range(start_row, end_row + 1):
            if board[column][r] == player:
                count += 1
                aligned_tokens.append((column, r))
                if count >= 4:
                    return aligned_tokens[-4:]
            else:
                count = 0
                aligned_tokens = []
        
        return None
    ```
    
6. **Vérification des alignements diagonaux**:
    
    python
    
    ```python
    def check_diagonal_down(board, last_pos, player):
        column, row = last_pos
        
        # Diagonale descendante (haut-gauche → bas-droite)
        aligned_tokens = []
        count = 0
        
        # Remonter jusqu'à 3 cases en haut à gauche
        start_offset = min(column, row, 3)
        col, r = column - start_offset, row - start_offset
        
        # Parcourir jusqu'à 3 cases en bas à droite
        while col < utils.COLUMNS and r < utils.ROWS and col <= column + 3 and r <= row + 3:
            if board[col][r] == player:
                count += 1
                aligned_tokens.append((col, r))
                if count >= 4:
                    return aligned_tokens[-4:]
            else:
                count = 0
                aligned_tokens = []
            col += 1
            r += 1
        
        return None
    ```
    
7. **Vérification des alignements diagonaux montants**:
    
    python
    
    ```python
    def check_diagonal_up(board, last_pos, player):
        column, row = last_pos
        
        # Diagonale montante (bas-gauche → haut-droite)
        aligned_tokens = []
        count = 0
        
        # Descendre jusqu'à 3 cases en bas à gauche
        start_offset = min(column, utils.ROWS - 1 - row, 3)
        col, r = column - start_offset, row + start_offset
        
        # Parcourir jusqu'à 3 cases en haut à droite
        while col < utils.COLUMNS and r >= 0 and col <= column + 3 and r >= row - 3:
            if board[col][r] == player:
                count += 1
                aligned_tokens.append((col, r))
                if count >= 4:
                    return aligned_tokens[-4:]
            else:
                count = 0
                aligned_tokens = []
            col += 1
            r -= 1
        
        return None
    ```
    
8. **Vérification complète de victoire**:
    
    python
    
    ```python
    def check_win(board, last_token_pos, player):
        if last_token_pos is None:
            return None
            
        # Vérification dans les 4 directions
        horizontal_win = check_horizontal(board, last_token_pos, player)
        if horizontal_win:
            return horizontal_win
            
        vertical_win = check_vertical(board, last_token_pos, player)
        if vertical_win:
            return vertical_win
            
        diagonal_down_win = check_diagonal_down(board, last_token_pos, player)
        if diagonal_down_win:
            return diagonal_down_win
            
        diagonal_up_win = check_diagonal_up(board, last_token_pos, player)
        if diagonal_up_win:
            return diagonal_up_win
            
        return None
    ```
    
9. **Vérification du plateau plein (match nul)**:
    
    python
    
    ```python
    def is_board_full(board):
        # Si aucune case de la ligne supérieure n'est vide, le plateau est plein
        for column in range(utils.COLUMNS):
            if board[column][0] == 0:
                return False
        return True
    ```
    
10. **Alternance des joueurs**:
    
    python
    
    ```python
    def switch_player(current_player):
        return 3 - current_player  # 1 devient 2, 2 devient 1
    ```
    
11. **Affichage console du plateau (pour débogage)**:
    
    python
    
    ```python
    def print_board(board):
        for row in range(utils.ROWS):
            line = "|"
            for column in range(utils.COLUMNS):
                if board[column][row] == 0:
                    line += " |"
                elif board[column][row] == 1:
                    line += "X|"
                else:
                    line += "O|"
            print(line)
        print("-" * (utils.COLUMNS * 2 + 1))
    ```
    

### Points de vigilance

1. **Vérification des limites**: Assurez-vous que toutes les vérifications d'alignement respectent les limites du plateau pour éviter les erreurs d'index.
2. **Performance des algorithmes**: Les vérifications d'alignement sont exécutées à chaque coup, donc leur efficacité est cruciale. Optimisez-les en limitant les vérifications aux zones affectées par le dernier coup.
3. **Cohérence de la représentation**: Maintenez une cohérence dans la représentation du plateau (ordre des indices, valeurs des joueurs) tout au long du code.
4. **Gestion des cas particuliers**: Considérez tous les cas de figure, notamment les bords du plateau et les situations où le joueur place un jeton dans une colonne pleine.
5. **Validité des entrées**: Validez toujours les entrées avant de modifier l'état du plateau pour éviter des comportements inattendus.
6. **Précision des algorithmes de vérification**: Les algorithmes de détection d'alignement doivent être précis et exhaustifs, couvrant les quatre directions possibles.
7. **Clonage du plateau**: Si vous devez créer une copie du plateau (pour l'IA ou les simulations), utilisez `numpy.copy()` pour éviter les références partagées.
8. **Détection des situations de match nul**: Veillez à ce que la détection d'un plateau plein soit correcte pour éviter des parties qui ne se terminent jamais.