## 3. Module d'affichage (`display.py`)

Ce module gère l'interface graphique et l'affichage des différents écrans du jeu.

### Fonctionnement détaillé

1. **Initialisation et chargement des ressources**:
    
    python
    
    ```python
    def init_display():
        # Chargement des images
        global board_img, red_token_img, yellow_token_img, background_img
        board_img = pygame.image.load(utils.resource_path("assets/board.png"))
        red_token_img = pygame.image.load(utils.resource_path("assets/red_token.png"))
        yellow_token_img = pygame.image.load(utils.resource_path("assets/yellow_token.png"))
        background_img = pygame.image.load(utils.resource_path("assets/background.png"))
        
        # Initialisation des polices
        global title_font, button_font, info_font
        title_font = pygame.font.Font(None, 72)
        button_font = pygame.font.Font(None, 48)
        info_font = pygame.font.Font(None, 36)
    ```
    
2. **Affichage du menu principal**:
    
    python
    
    ```python
    def draw_menu(screen):
        # Arrière-plan
        screen.blit(background_img, (0, 0))
        
        # Titre
        title_surf = title_font.render("Puissance 4", True, utils.BLUE)
        title_rect = title_surf.get_rect(center=(utils.WINDOW_WIDTH // 2, 100))
        screen.blit(title_surf, title_rect)
        
        # Boutons
        buttons = {}
        
        # Bouton mode 2 joueurs
        buttons["human"] = utils.create_button(
            screen, 
            "2 Joueurs", 
            (utils.WINDOW_WIDTH // 2, 250), 
            (300, 70), 
            utils.RED, 
            utils.LIGHT_RED
        )
        
        # Bouton mode ordinateur
        buttons["computer"] = utils.create_button(
            screen, 
            "Jouer contre l'ordinateur", 
            (utils.WINDOW_WIDTH // 2, 350), 
            (300, 70), 
            utils.YELLOW, 
            utils.LIGHT_YELLOW
        )
        
        # Bouton règles
        buttons["rules"] = utils.create_button(
            screen, 
            "Règles", 
            (utils.WINDOW_WIDTH // 2, 450), 
            (300, 70), 
            utils.GREEN, 
            utils.LIGHT_GREEN
        )
        
        # Bouton quitter
        buttons["quit"] = utils.create_button(
            screen, 
            "Quitter", 
            (utils.WINDOW_WIDTH // 2, 550), 
            (300, 70), 
            utils.GRAY, 
            utils.LIGHT_GRAY
        )
        
        return buttons
    ```
    
3. **Affichage du plateau de jeu**:
    
    python
    
    ```python
    def draw_board(screen, board):
        # Arrière-plan
        screen.blit(background_img, (0, 0))
        
        # Calcul des dimensions et position du plateau
        board_x = (utils.WINDOW_WIDTH - utils.BOARD_WIDTH) // 2
        board_y = (utils.WINDOW_HEIGHT - utils.BOARD_HEIGHT) // 2 + 50  # Décalé vers le bas
        
        # Affichage du plateau
        screen.blit(board_img, (board_x, board_y))
        
        # Prévisualisation
        mouse_x, _ = pygame.mouse.get_pos()
        column = utils.pixel_to_column(mouse_x)
        if 0 <= column < utils.COLUMNS:
            draw_token_preview(screen, column, current_player)
        
        # Affichage des jetons
        for column in range(utils.COLUMNS):
            for row in range(utils.ROWS):
                if board[column][row] == 1:
                    draw_token(screen, column, row, 1)
                elif board[column][row] == 2:
                    draw_token(screen, column, row, 2)
    ```
    
4. **Affichage d'un jeton**:
    
    python
    
    ```python
    def draw_token(screen, column, row, player):
        # Conversion des coordonnées logiques en pixels
        x, y = utils.board_to_pixel(column, row)
        
        # Ajout des décalages pour centrer dans le plateau
        x += (utils.WINDOW_WIDTH - utils.BOARD_WIDTH) // 2
        y += (utils.WINDOW_HEIGHT - utils.BOARD_HEIGHT) // 2 + 50
        
        # Affichage du jeton selon le joueur
        if player == 1:
            screen.blit(red_token_img, (x - utils.TOKEN_RADIUS, y - utils.TOKEN_RADIUS))
        else:
            screen.blit(yellow_token_img, (x - utils.TOKEN_RADIUS, y - utils.TOKEN_RADIUS))
    ```
    
5. **Prévisualisation du placement d'un jeton**:
    
    python
    
    ```python
    def draw_token_preview(screen, column, player):
        # Position en haut de la colonne
        x, _ = utils.board_to_pixel(column, 0)
        x += (utils.WINDOW_WIDTH - utils.BOARD_WIDTH) // 2
        y = (utils.WINDOW_HEIGHT - utils.BOARD_HEIGHT) // 2 + 25  # Au-dessus du plateau
        
        # Jeton semi-transparent
        if player == 1:
            token_img = red_token_img.copy()
        else:
            token_img = yellow_token_img.copy()
            
        # Ajustement de la transparence
        token_img.set_alpha(128)
        screen.blit(token_img, (x - utils.TOKEN_RADIUS, y - utils.TOKEN_RADIUS))
    ```
    
6. **Affichage des informations de jeu**:
    
    python
    
    ```python
    def draw_game_info(screen, current_player, player_names, scores, game_state):
        # Affichage du joueur actif
        player_text = f"Tour de {player_names[f'player{current_player}']}"
        player_color = utils.RED if current_player == 1 else utils.YELLOW
        player_surf = info_font.render(player_text, True, player_color)
        screen.blit(player_surf, (20, 20))
        
        # Affichage des scores
        score_text = f"Score: {player_names['player1']}: {scores['player1']} - {player_names['player2']}: {scores['player2']}"
        score_surf = info_font.render(score_text, True, utils.WHITE)
        screen.blit(score_surf, (20, 60))
        
        # Boutons
        buttons = {}
        
        # Bouton nouvelle partie
        buttons["new_game"] = utils.create_button(
            screen, 
            "Nouvelle partie", 
            (utils.WINDOW_WIDTH - 150, 30), 
            (250, 50), 
            utils.GREEN, 
            utils.LIGHT_GREEN
        )
        
        # Bouton menu principal
        buttons["menu"] = utils.create_button(
            screen, 
            "Menu principal", 
            (utils.WINDOW_WIDTH - 150, 90), 
            (250, 50), 
            utils.BLUE, 
            utils.LIGHT_BLUE
        )
        
        # Bouton d'aide
        buttons["help"] = utils.create_button(
            screen, 
            "Aide", 
            (utils.WINDOW_WIDTH - 150, 150), 
            (250, 50), 
            utils.PURPLE, 
            utils.LIGHT_PURPLE
        )
        
        return buttons
    ```
    
7. **Mise en évidence de l'alignement gagnant**:
    
    python
    
    ```python
    def highlight_winning_tokens(screen, board, winning_tokens):
        if winning_tokens is None:
            return
            
        # Dessine un contour ou un effet lumineux autour des jetons gagnants
        for column, row in winning_tokens:
            x, y = utils.board_to_pixel(column, row)
            x += (utils.WINDOW_WIDTH - utils.BOARD_WIDTH) // 2
            y += (utils.WINDOW_HEIGHT - utils.BOARD_HEIGHT) // 2 + 50
            
            # Dessine un cercle de surbrillance
            glow_radius = utils.TOKEN_RADIUS + 5
            pygame.draw.circle(screen, utils.WHITE, (x, y), glow_radius, 3)
    ```
    
8. **Affichage de la fin de partie**:
    
    python
    
    ```python
    def draw_game_over(screen, winner, winning_tokens, scores, player_names):
        # Affichage du plateau avec les jetons
        draw_board(screen, board)
        
        # Mise en évidence de l'alignement gagnant
        highlight_winning_tokens(screen, board, winning_tokens)
        
        # Panneau semi-transparent
        overlay = pygame.Surface((utils.WINDOW_WIDTH, utils.WINDOW_HEIGHT))
        overlay.set_alpha(180)
        overlay.fill(utils.BLACK)
        screen.blit(overlay, (0, 0))
        
        # Message de fin de partie
        if winner:
            message = f"{player_names[winner]} a gagné !"
            color = utils.RED if winner == "player1" else utils.YELLOW
        else:
            message = "Match nul !"
            color = utils.WHITE
            
        message_surf = title_font.render(message, True, color)
        message_rect = message_surf.get_rect(center=(utils.WINDOW_WIDTH // 2, utils.WINDOW_HEIGHT // 2 - 100))
        screen.blit(message_surf, message_rect)
        
        # Affichage du score
        score_text = f"Score: {player_names['player1']}: {scores['player1']} - {player_names['player2']}: {scores['player2']}"
        score_surf = info_font.render(score_text, True, utils.WHITE)
        score_rect = score_surf.get_rect(center=(utils.WINDOW_WIDTH // 2, utils.WINDOW_HEIGHT // 2))
        screen.blit(score_surf, score_rect)
        
        # Boutons
        buttons = {}
        
        # Bouton rejouer
        buttons["play_again"] = utils.create_button(
            screen, 
            "Rejouer", 
            (utils.WINDOW_WIDTH // 2, utils.WINDOW_HEIGHT // 2 + 100), 
            (250, 70), 
            utils.GREEN, 
            utils.LIGHT_GREEN
        )
        
        # Bouton menu principal
        buttons["menu"] = utils.create_button(
            screen, 
            "Menu principal", 
            (utils.WINDOW_WIDTH // 2, utils.WINDOW_HEIGHT // 2 + 200), 
            (250, 70), 
            utils.BLUE, 
            utils.LIGHT_BLUE
        )
        
        return buttons
    ```
    
9. **Affichage des règles du jeu**:
    
    python
    
    ```python
    def draw_rules(screen):
        # Arrière-plan
        screen.blit(background_img, (0, 0))
        
        # Titre
        title_surf = title_font.render("Règles du Puissance 4", True, utils.BLUE)
        title_rect = title_surf.get_rect(center=(utils.WINDOW_WIDTH // 2, 80))
        screen.blit(title_surf, title_rect)
        
        # Texte des règles
        rules_text = [
            "Objectif : Aligner 4 jetons de votre couleur horizontalement,",
            "verticalement ou en diagonale avant votre adversaire.",
            "",
            "Comment jouer :",
            "- Les joueurs jouent à tour de rôle",
            "- Cliquez sur une colonne pour y placer votre jeton",
            "- Le jeton tombe jusqu'à la position la plus basse disponible",
            "- Le premier à aligner 4 jetons de sa couleur gagne",
            "- Si le plateau est rempli sans alignement, c'est un match nul"
        ]
        
        y_pos = 180
        for line in rules_text:
            rule_surf = info_font.render(line, True, utils.WHITE)
            rule_rect = rule_surf.get_rect(center=(utils.WINDOW_WIDTH // 2, y_pos))
            screen.blit(rule_surf, rule_rect)
            y_pos += 40
        
        # Bouton retour
        buttons = {}
        buttons["back"] = utils.create_button(
            screen, 
            "Retour", 
            (utils.WINDOW_WIDTH // 2, y_pos + 60), 
            (250, 70), 
            utils.GREEN, 
            utils.LIGHT_GREEN
        )
        
        return buttons
    ```
    

### Points de vigilance

1. **Chargement des ressources**: Assurez-vous que les images et polices sont correctement chargées au démarrage, avec gestion des erreurs en cas de fichier manquant.
2. **Gestion des dimensions**: Veillez à ce que les éléments graphiques soient correctement positionnés, quelle que soit la résolution de l'écran.
3. **Consistance visuelle**: Maintenez une cohérence visuelle entre les différents écrans (couleurs, polices, styles de boutons).
4. **Performance de l'affichage**: Évitez de redessiner les éléments statiques à chaque frame. Utilisez des surfaces Pygame prédéfinies pour les éléments qui ne changent pas.
5. **Réactivité de l'interface**: Assurez-vous que les boutons et éléments interactifs répondent immédiatement aux actions de l'utilisateur.
6. **Gestion de la transparence**: Attention aux opérations de transparence qui peuvent être coûteuses en performance. Limitez-les aux éléments nécessaires.
7. **Prévisualisation du placement**: Assurez-vous que la prévisualisation du jeton ne s'affiche que pour les colonnes valides et dans les bonnes couleurs.
8. **Adaptation aux changements d'état**: Gérez correctement les transitions entre les différents écrans pour éviter les affichages incohérents.
9. **Lisibilité du texte**: Assurez-vous que tout le texte affiché est bien lisible sur le fond, avec un contraste suffisant et une taille de police adaptée.
10. **Réutilisation de code**: Créez des fonctions réutilisables pour les éléments communs (dessin de boutons, affichage de texte...) afin d'éviter la duplication de code.
11. **Animation fluide**: Si vous implémentez des animations, assurez-vous qu'elles restent fluides même sur des configurations modestes.
12. **Gestion d'erreurs graphiques**: Prévoyez un affichage de secours en cas d'erreur de chargement des ressources graphiques.
13. **Cohérence des zones cliquables**: Assurez-vous que les zones cliquables des boutons correspondent exactement à leur apparence visuelle.