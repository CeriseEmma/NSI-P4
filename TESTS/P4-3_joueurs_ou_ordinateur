def deux_joueur():
    """Demande et renvoie les noms des deux joueurs."""
    joueur_1 = input("Joueur 1 quel est votre nom? : ")
    joueur_2 = input("Joueur 2 quel est votre nom? : ")
    return joueur_1, joueur_2


def un_joueur():
    """Demande le nom du joueur humain et configure l'ordinateur comme adversaire."""
    joueur_1 = input("Quel est votre nom? : ")
    joueur_2 = "Ordinateur"
    return joueur_1, joueur_2


def grille_vide():
    """
    Construit un tableau à deux dimensions de taille 6 x 7 (6 lignes et 7 colonnes).
    Chaque case contient la valeur 0.
    Renvoie le tableau grille.
    """
    grille = []
    for i in range(6):
        tab = []
        for j in range(7):
            tab.append(0)
        grille.append(tab)
    return grille


def affiche_grille(grille):
    """
    Affiche la grille de jeu dans le terminal avec un design amélioré.
    Utilise des caractères Unicode et des couleurs ANSI si disponibles.
    """
    # Couleurs ANSI (si le terminal les supporte)
    ROUGE = '\033[91m'
    JAUNE = '\033[93m'
    BLEU = '\033[94m'
    RESET = '\033[0m'

    # Caractères pour la grille
    VIDE = " "
    PION_B = "●"  # Pion du joueur 1
    PION_V = "●"  # Pion du joueur 2

    # Dessine l'en-tête avec les numéros de colonnes
    print("\n     ", end="")
    for j in range(1, 8):
        print(f" {j}  ", end="")
    print()

    # Dessine le haut de la grille
    print("    ┌" + "───┬" * 6 + "───┐")

    # Dessine les lignes de la grille
    for i in range(5, -1, -1):
        print(f" {i + 1}  │", end="")
        for j in range(7):
            if grille[i][j] == 0:
                print(f" {VIDE} │", end="")
            elif grille[i][j] == 'B':
                print(f" {BLEU}{PION_B}{RESET} │", end="")
            else:  # 'V'
                print(f" {JAUNE}{PION_V}{RESET} │", end="")
        print()

        # Dessine les séparateurs de ligne (sauf pour la dernière)
        if i > 0:
            print("    ├" + "───┼" * 6 + "───┤")
        else:
            print("    └" + "───┴" * 6 + "───┘")


def coup_possible(grille, colonne):
    """
    Détermine s'il est possible de jouer dans la colonne spécifiée.
    Renvoie (True, ligne) si possible, (False, 0) sinon.
    """
    for i in range(6):
        if grille[i][colonne] == 0:
            return True, i
    return False, 0


def verifier_victoire(grille, symbole):
    """
    Vérifie si le joueur avec le symbole donné a gagné.
    Renvoie True si victoire, False sinon.
    """
    # Vérification horizontale
    for i in range(6):
        for j in range(4):
            if (grille[i][j] == symbole and grille[i][j + 1] == symbole and
                    grille[i][j + 2] == symbole and grille[i][j + 3] == symbole):
                return True

    # Vérification verticale
    for i in range(3):
        for j in range(7):
            if (grille[i][j] == symbole and grille[i + 1][j] == symbole and
                    grille[i + 2][j] == symbole and grille[i + 3][j] == symbole):
                return True

    # Vérification diagonale (montante)
    for i in range(3):
        for j in range(4):
            if (grille[i][j] == symbole and grille[i + 1][j + 1] == symbole and
                    grille[i + 2][j + 2] == symbole and grille[i + 3][j + 3] == symbole):
                return True

    # Vérification diagonale (descendante)
    for i in range(3, 6):
        for j in range(4):
            if (grille[i][j] == symbole and grille[i - 1][j + 1] == symbole and
                    grille[i - 2][j + 2] == symbole and grille[i - 3][j + 3] == symbole):
                return True

    return False


def grille_pleine(grille):
    """
    Vérifie si la grille est pleine.
    Renvoie True si pleine, False sinon.
    """
    for j in range(7):
        if coup_possible(grille, j)[0]:
            return False
    return True


def jouer(grille, j, j_nom):
    """
    Joue un coup du joueur j dans la colonne choisie.
    Renvoie la grille mise à jour et un booléen indiquant si le coup a été joué.
    """
    while True:
        try:
            colonne = int(input(f"{j_nom}, dans quelle colonne voulez-vous jouer? (1-7) : ")) - 1

            # Vérification que la colonne est valide
            if colonne < 0 or colonne > 6:
                print("Erreur: Veuillez entrer un nombre entre 1 et 7.")
                continue

            possible, ligne = coup_possible(grille, colonne)
            if possible:
                if j == 1:
                    grille[ligne][colonne] = 'B'
                else:
                    grille[ligne][colonne] = 'V'
                return grille, True
            else:
                print("Cette colonne est pleine. Veuillez choisir une autre colonne.")
        except ValueError:
            print("Erreur: Veuillez entrer un nombre valide.")


def choix_difficulte():
    """Permet au joueur de choisir le niveau de difficulté de l'ordinateur."""
    while True:
        try:
            print("\nChoisissez le niveau de difficulté:")
            print("1. Facile (aléatoire)")
            print("2. Moyen (détecte les coups gagnants)")
            print("3. Difficile (stratégie plus avancée)")
            difficulte = int(input("Votre choix (1-3): "))
            if 1 <= difficulte <= 3:
                return difficulte
            else:
                print("Veuillez entrer un nombre entre 1 et 3.")
        except ValueError:
            print("Veuillez entrer un nombre valide.")


def coup_ordi_facile(grille):
    """
    L'ordinateur joue un coup aléatoire dans une colonne disponible.
    Mode facile - totalement aléatoire.
    """
    import random

    # Liste des colonnes où il est possible de jouer
    colonnes_disponibles = []
    for col in range(7):
        if coup_possible(grille, col)[0]:
            colonnes_disponibles.append(col)

    # Choix aléatoire d'une colonne disponible
    if colonnes_disponibles:
        return random.choice(colonnes_disponibles)
    return None  # Ne devrait jamais arriver si la grille n'est pas pleine


def coup_gagnant(grille, symbole):
    """
    Vérifie si un joueur avec le symbole donné peut gagner en un coup.
    Renvoie le numéro de colonne pour gagner, ou None si pas de coup gagnant.
    """
    # Teste chaque colonne où il est possible de jouer
    for col in range(7):
        possible, ligne = coup_possible(grille, col)
        if possible:
            # Simule le coup
            grille[ligne][col] = symbole
            # Vérifie si ce coup est gagnant
            if verifier_victoire(grille, symbole):
                # Annule le coup simulé
                grille[ligne][col] = 0
                return col
            # Annule le coup simulé
            grille[ligne][col] = 0

    return None  # Pas de coup gagnant trouvé


def coup_ordi_moyen(grille):
    """
    L'ordinateur joue de façon plus intelligente.
    Mode moyen - cherche à gagner ou à bloquer l'adversaire.
    """
    # Vérifie d'abord si l'ordinateur peut gagner en un coup
    col_gagnante = coup_gagnant(grille, 'V')
    if col_gagnante is not None:
        return col_gagnante

    # Sinon, vérifie si l'adversaire peut gagner et bloque son coup
    col_bloquante = coup_gagnant(grille, 'B')
    if col_bloquante is not None:
        return col_bloquante

    # Si aucun coup critique, joue aléatoirement
    return coup_ordi_facile(grille)


def evaluer_position(grille, ligne, col, symbole):
    """
    Évalue la valeur stratégique d'une position pour le symbole donné.
    Plus le score est élevé, meilleure est la position.
    """
    score = 0
    adversaire = 'B' if symbole == 'V' else 'V'

    # Vérifie les alignements potentiels dans toutes les directions
    # Horizontal, vertical, diagonale montante, diagonale descendante
    directions = [
        [(0, 1), (0, -1)],  # Horizontal
        [(1, 0), (-1, 0)],  # Vertical
        [(1, 1), (-1, -1)],  # Diagonale montante
        [(1, -1), (-1, 1)]  # Diagonale descendante
    ]

    for dir_pair in directions:
        count_symbole = 1  # Compte le pion qu'on placerait
        count_vide = 0  # Compte les cases vides

        # Vérifie dans les deux directions opposées
        for dx, dy in dir_pair:
            # Vérifie jusqu'à 3 cases dans cette direction
            for dist in range(1, 4):
                new_ligne = ligne + dx * dist
                new_col = col + dy * dist

                # Vérifie que les coordonnées sont valides
                if 0 <= new_ligne < 6 and 0 <= new_col < 7:
                    if grille[new_ligne][new_col] == symbole:
                        count_symbole += 1
                    elif grille[new_ligne][new_col] == 0:
                        count_vide += 1
                    else:  # Case occupée par l'adversaire
                        break
                else:
                    break

        # Attribution des scores selon les configurations
        if count_symbole == 4:
            score += 100  # Victoire immédiate
        elif count_symbole == 3 and count_vide >= 1:
            score += 5  # Peut former un alignement de 4 au prochain coup
        elif count_symbole == 2 and count_vide >= 2:
            score += 2  # Peut former un alignement de 3 au prochain coup

    # Favorise légèrement le centre de la grille
    if col == 3:
        score += 1

    return score


def coup_ordi_difficile(grille):
    """
    L'ordinateur joue avec une stratégie avancée.
    Mode difficile - évalue la valeur de chaque coup possible.
    """
    meilleur_score = -1
    meilleure_colonne = 3  # Par défaut, le centre (souvent un bon choix)

    # Vérifie d'abord si l'ordinateur peut gagner en un coup
    col_gagnante = coup_gagnant(grille, 'V')
    if col_gagnante is not None:
        return col_gagnante

    # Sinon, vérifie si l'adversaire peut gagner et bloque son coup
    col_bloquante = coup_gagnant(grille, 'B')
    if col_bloquante is not None:
        return col_bloquante

    # Évalue chaque colonne disponible
    for col in range(7):
        possible, ligne = coup_possible(grille, col)
        if possible:
            # Calcule le score pour cette position
            score = evaluer_position(grille, ligne, col, 'V')

            # Met à jour la meilleure colonne si nécessaire
            if score > meilleur_score:
                meilleur_score = score
                meilleure_colonne = col

    return meilleure_colonne


def jouer_ordi(grille, difficulte):
    """
    Fait jouer l'ordinateur selon le niveau de difficulté choisi.
    Renvoie la grille mise à jour.
    """
    print("\nL'Ordinateur réfléchit...")
    import time
    time.sleep(1)  # Pause pour simuler la réflexion

    # Choix de la colonne selon le niveau de difficulté
    if difficulte == 1:
        colonne = coup_ordi_facile(grille)
    elif difficulte == 2:
        colonne = coup_ordi_moyen(grille)
    else:  # difficulte == 3
        colonne = coup_ordi_difficile(grille)

    # Trouve la ligne où placer le pion
    possible, ligne = coup_possible(grille, colonne)
    if possible:
        grille[ligne][colonne] = 'V'  # Place le pion de l'ordinateur
        print(f"L'Ordinateur a joué dans la colonne {colonne + 1}")

    return grille


def puissance4_vs_ordi():
    """Fonction principale du jeu Puissance 4 contre l'ordinateur."""
    print("\n===== PUISSANCE 4 CONTRE L'ORDINATEUR =====\n")
    j_1, j_2 = un_joueur()  # Configure le joueur humain et l'ordinateur
    difficulte = choix_difficulte()  # Choix du niveau de difficulté
    grille = grille_vide()  # Initialise la grille vide
    tour = 0  # Compteur de tours initialisé à 0

    while True:  # Boucle principale du jeu
        tour += 1  # Incrémente le compteur de tours
        affiche_grille(grille)  # Affiche l'état actuel de la grille

        # Tour du joueur humain
        print(f"\nTour {tour}: {j_1} (B) à vous de jouer!")  # Annonce le tour du joueur
        grille, coup_joue = jouer(grille, 1, j_1)  # Le joueur joue son coup
        if not coup_joue:  # Si le coup n'a pas été joué (ne devrait pas arriver)
            continue  # Passe au tour suivant

        affiche_grille(grille)  # Affiche la grille après le coup du joueur

        # Vérification de victoire du joueur
        if verifier_victoire(grille, 'B'):  # Vérifie si le joueur a gagné
            print(f"\nFélicitations! {j_1} a gagné en {tour} tours!")  # Message de victoire
            break  # Fin de la partie

        # Vérification de match nul
        if grille_pleine(grille):  # Vérifie si la grille est pleine (match nul)
            print("\nMatch nul! La grille est pleine.")  # Message de match nul
            break  # Fin de la partie

        # Tour de l'ordinateur
        print(f"\nTour {tour}: {j_2} (V) joue...")  # Annonce le tour de l'ordinateur
        grille = jouer_ordi(grille, difficulte)  # L'ordinateur joue son coup

        # Vérification de victoire de l'ordinateur
        if verifier_victoire(grille, 'V'):  # Vérifie si l'ordinateur a gagné
            affiche_grille(grille)  # Affiche la grille finale
            print(f"\n{j_2} a gagné en {tour} tours!")  # Message de défaite
            break  # Fin de la partie

        # Vérification de match nul après le coup de l'ordinateur
        if grille_pleine(grille):  # Vérifie si la grille est pleine
            affiche_grille(grille)  # Affiche la grille finale
            print("\nMatch nul! La grille est pleine.")  # Message de match nul
            break  # Fin de la partie

    # Proposition de rejouer une fois la partie terminée
    rejouer = input("\nVoulez-vous rejouer? (o/n) : ")  # Demande si le joueur veut rejouer
    if rejouer.lower() == 'o':  # Si la réponse est oui (o ou O)
        puissance4()  # Retourne au menu principal
    else:  # Si la réponse est non
        print("\nMerci d'avoir joué! À bientôt!")  # Message de fin


def puissance4_2joueurs():
    """Fonction principale du jeu Puissance 4 pour 2 joueurs humains."""
    print("\n===== PUISSANCE 4 - MODE 2 JOUEURS =====\n")
    j_1, j_2 = deux_joueur()
    grille = grille_vide()
    tour = 0

    while True:
        tour += 1
        affiche_grille(grille)

        # Tour du joueur 1
        print(f"\nTour {tour}: {j_1} (B) à vous de jouer!")
        grille, coup_joue = jouer(grille, 1, j_1)
        if not coup_joue:
            continue

        affiche_grille(grille)

        # Vérification de victoire du joueur 1
        if verifier_victoire(grille, 'B'):
            print(f"\nFélicitations! {j_1} a gagné en {tour} tours!")
            break

        # Vérification de match nul
        if grille_pleine(grille):
            print("\nMatch nul! La grille est pleine.")
            break

        # Tour du joueur 2
        print(f"\nTour {tour}: {j_2} (V) à vous de jouer!")
        grille, coup_joue = jouer(grille, 2, j_2)
        if not coup_joue:
            continue

        # Vérification de victoire du joueur 2
        if verifier_victoire(grille, 'V'):
            affiche_grille(grille)
            print(f"\nFélicitations! {j_2} a gagné en {tour} tours!")
            break

        # Vérification de match nul
        if grille_pleine(grille):
            affiche_grille(grille)
            print("\nMatch nul! La grille est pleine.")
            break

    # Proposition de rejouer
    rejouer = input("\nVoulez-vous rejouer? (o/n) : ")
    if rejouer.lower() == 'o':
        puissance4()  # Retourne au menu principal
    else:
        print("\nMerci d'avoir joué! À bientôt!")


def puissance4():
    """Fonction de sélection du mode de jeu."""
    print("\n===== PUISSANCE 4 =====\n")
    print("Choisissez le mode de jeu:")
    print("1. Joueur contre Joueur")
    print("2. Joueur contre Ordinateur")

    while True:
        try:
            mode = int(input("Votre choix (1-2): "))
            if mode == 1:
                puissance4_2joueurs()  # Jouer à 2 joueurs
                break
            elif mode == 2:
                puissance4_vs_ordi()  # Jouer contre l'ordinateur
                break
            else:
                print("Veuillez entrer 1 ou 2.")
        except ValueError:
            print("Veuillez entrer un nombre valide.")


# Point d'entrée du programme
if __name__ == "__main__":
    puissance4()  # Lance le menu de sélection du mode
    
