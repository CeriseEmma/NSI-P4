## 5. Module utilitaire (`utils.py`)

Ce module contient les constantes et fonctions auxiliaires utilisées par les autres composants du jeu.

### Fonctionnement détaillé

1. **Définition des constantes**:
    
    python
    
    ```python
    # Dimensions de la fenêtre
    WINDOW_WIDTH = 800
    WINDOW_HEIGHT = 700
    
    # Dimensions du plateau
    BOARD_WIDTH = 700
    BOARD_HEIGHT = 600
    
    # Configuration du plateau
    COLUMNS = 7
    ROWS = 6
    CELL_SIZE = 100
    TOKEN_RADIUS = 45
    
    # Couleurs
    RED = (255, 0, 0)
    LIGHT_RED = (255, 80, 80)
    YELLOW = (255, 255, 0)
    LIGHT_YELLOW = (255, 255, 120)
    BLUE = (0, 0, 255)
    LIGHT_BLUE = (80, 80, 255)
    GREEN = (0, 255, 0)
    LIGHT_GREEN = (80, 255, 80)
    PURPLE = (128, 0, 128)
    LIGHT_PURPLE = (180, 80, 180)
    BLACK = (0, 0, 0)
    WHITE = (255, 255, 255)
    GRAY = (128, 128, 128)
    LIGHT_GRAY = (180, 180, 180)
    
    # Fréquence d'images
    FPS = 60
    ```
    
2. **Conversion de coordonnées plateau-pixels**:
    
    python
    
    ```python
    def board_to_pixel(column, row):
        """
        Convertit les coordonnées logiques du plateau en coordonnées pixels pour l'affichage.
        
        Args:
            column (int): Index de la colonne (0-6)
            row (int): Index de la ligne (0-5)
            
        Returns:
            tuple: Coordonnées (x, y) en pixels
        """
        # Le centre de chaque case est calculé en multipliant par CELL_SIZE
        # et en ajoutant CELL_SIZE / 2 pour arriver au centre
        x = column * CELL_SIZE + CELL_SIZE // 2
        y = row * CELL_SIZE + CELL_SIZE // 2
        
        return (x, y)
    ```
    
3. **Conversion de pixels en colonne**:
    
    python
    
    ```python
    def pixel_to_column(x):
        """
        Convertit une position horizontale en pixels en index de colonne.
        
        Args:
            x (int): Position horizontale en pixels
            
        Returns:
            int: Index de la colonne (0-6) ou -1 si hors limites
        """
        # Ajustement pour le décalage du plateau sur l'écran
        board_x = (WINDOW_WIDTH - BOARD_WIDTH) // 2
        adjusted_x = x - board_x
        
        # Si le clic est en dehors du plateau, retourner -1
        if adjusted_x < 0 or adjusted_x >= BOARD_WIDTH:
            return -1
            
        # Division par la taille d'une cellule pour obtenir l'index de colonne
        column = adjusted_x // CELL_SIZE
        
        # Vérification des limites
        if column < 0 or column >= COLUMNS:
            return -1
            
        return column
    ```
    
4. **Gestion des chemins de ressources**:
    
    python
    
    ```python
    import os
    import sys
    
    def resource_path(relative_path):
        """
        Construit le chemin absolu vers une ressource, compatible avec PyInstaller.
        
        Args:
            relative_path (str): Chemin relatif vers la ressource
            
        Returns:
            str: Chemin absolu vers la ressource
        """
        # Détermination si l'application est exécutée normalement ou "bundlée" par PyInstaller
        if getattr(sys, 'frozen', False):
            # L'application est "bundlée"
            base_path = sys._MEIPASS
        else:
            # L'application est exécutée normalement
            base_path = os.path.abspath(".")
            
        return os.path.join(base_path, relative_path)
    ```
    
5. **Création et gestion des boutons**:
    
    python
    
    ```python
    import pygame
    
    def create_button(screen, text, position, size, color, hover_color=None):
        """
        Crée et dessine un bouton interactif sur l'écran.
        
        Args:
            screen (pygame.Surface): Surface de l'écran
            text (str): Texte du bouton
            position (tuple): Position centrale (x, y) du bouton
            size (tuple): Dimensions (largeur, hauteur) du bouton
            color (tuple): Couleur RGB du bouton
            hover_color (tuple, optional): Couleur RGB au survol
            
        Returns:
            pygame.Rect: Rectangle du bouton (pour la détection des clics)
        """
        if hover_color is None:
            hover_color = color
            
        # Création du rectangle du bouton
        button_rect = pygame.Rect(0, 0, size[0], size[1])
        button_rect.center = position
        
        # Vérification si la souris survole le bouton
        mouse_pos = pygame.mouse.get_pos()
        is_hovering = button_rect.collidepoint(mouse_pos)
        
        # Détermination de la couleur à utiliser
        button_color = hover_color if is_hovering else color
        
        # Dessin du rectangle du bouton
        pygame.draw.rect(screen, button_color, button_rect, border_radius=10)
        pygame.draw.rect(screen, WHITE, button_rect, width=2, border_radius=10)
        
        # Création et positionnement du texte
        font = pygame.font.Font(None, 32)
        text_surf = font.render(text, True, WHITE)
        text_rect = text_surf.get_rect(center=button_rect.center)
        screen.blit(text_surf, text_rect)
        
        return button_rect
    ```
    
6. **Test de collision point-rectangle**:
    
    python
    
    ```python
    def is_point_in_rect(point, rect):
        """
        Vérifie si un point est à l'intérieur d'un rectangle.
        
        Args:
            point (tuple): Coordonnées (x, y) du point
            rect (pygame.Rect): Rectangle à tester
            
        Returns:
            bool: True si le point est dans le rectangle, False sinon
        """
        return rect.collidepoint(point)
    ```
    
7. **Fonction d'affichage de texte**:
    
    python
    
    ```python
    def draw_text(screen, text, font, color, position, center=True):
        """
        Affiche un texte à l'écran.
        
        Args:
            screen (pygame.Surface): Surface de l'écran
            text (str): Texte à afficher
            font (pygame.font.Font): Police de caractères
            color (tuple): Couleur RGB du texte
            position (tuple): Position (x, y) du texte
            center (bool): Si True, le texte est centré sur la position
        """
        text_surf = font.render(text, True, color)
        
        if center:
            text_rect = text_surf.get_rect(center=position)
        else:
            text_rect = text_surf.get_rect(topleft=position)
            
        screen.blit(text_surf, text_rect)
    ```
    

### Points de vigilance

1. **Cohérence des constantes**: Assurez-vous que les constantes sont cohérentes entre elles (par exemple, BOARD_WIDTH doit être compatible avec COLUMNS et CELL_SIZE).
2. **Gestion des chemins**: La fonction `resource_path` doit fonctionner correctement quel que soit le mode d'exécution (développement ou distribution).
3. **Conversion de coordonnées**: Les fonctions de conversion entre coordonnées logiques et physiques doivent être précises et tenir compte des décalages du plateau sur l'écran.
4. **Compatibilité des couleurs**: Vérifiez que toutes les couleurs sont définies au format RGB et sont compatibles avec Pygame.
5. **Performance des fonctions utilitaires**: Ces fonctions étant souvent appelées à chaque frame, optimisez-les autant que possible.
6. **Gestion des erreurs**: Implémentez des vérifications pour éviter les erreurs courantes (débordement d'indice, division par zéro, etc.).
7. **Documentation**: Documentez clairement chaque constante et fonction pour faciliter leur utilisation par les autres modules.
8. **Cohérence des noms**: Utilisez une convention de nommage cohérente pour toutes les constantes et fonctions.
9. **Évolution des constantes**: Concevez votre système de constantes de manière à pouvoir facilement ajuster des paramètres comme la taille de la fenêtre ou les dimensions du plateau.
10. **Isolation des dépendances**: Évitez les dépendances circulaires entre les modules pour maintenir une architecture propre.