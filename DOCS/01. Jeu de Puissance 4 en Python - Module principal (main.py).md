## 1. Module principal (`main.py`)

Ce module est le cœur de votre application, coordonnant tous les autres composants et gérant la boucle de jeu principale.

### Fonctionnement détaillé

1. **Préparation de l'environnement**:
    - Importation des bibliothèques standard: `pygame`, `numpy`, `sys`, `time`
    - Importation des modules personnalisés: `game_logic`, `display`, `computer_player`, `utils`
    - Initialisation de Pygame: `pygame.init()`, `pygame.font.init()`, `pygame.display.init()`
    - Configuration de l'horloge interne: `clock = pygame.time.Clock()`
2. **Initialisation des variables globales**:
    - État du jeu: `game_state = "MENU"`
    - Scores: `scores = {"player1": 0, "player2": 0}`
    - Joueur actuel: `current_player = 1`
    - Plateau de jeu: `board = game_logic.init_board()`
    - Dernière position de jeton: `last_token_pos = None`
    - Jetons gagnants: `winning_tokens = None`
    - Noms des joueurs: `player_names = {"player1": "Joueur 1", "player2": "Joueur 2"}`
3. **Configuration de la fenêtre**:
    - Création de la fenêtre: `screen = pygame.display.set_mode((utils.WINDOW_WIDTH, utils.WINDOW_HEIGHT))`
    - Titre de la fenêtre: `pygame.display.set_caption("Puissance 4")`
    - Icône du jeu: `icon = pygame.image.load(utils.resource_path("assets/icon.png"))`
    - Application de l'icône: `pygame.display.set_icon(icon)`
4. **Fonction d'initialisation de partie**:
    
    python
    
    ```python
    def init_game(game_mode):
        global board, current_player, last_token_pos, winning_tokens
        board = game_logic.init_board()
        current_player = 1
        last_token_pos = None
        winning_tokens = None
        if game_mode == "GAME_VS_HUMAN":
            game_state = "GAME_VS_HUMAN"
        else:
            game_state = "GAME_VS_COMPUTER"
        return game_state
    ```
    
5. **Gestion des événements principaux**:
    
    python
    
    ```python
    def handle_events():
        global game_state
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if game_state == "MENU":
                    game_state = handle_menu_events(mouse_pos)
                elif game_state == "GAME_VS_HUMAN":
                    game_state = handle_human_game_events(mouse_pos)
                elif game_state == "GAME_VS_COMPUTER":
                    game_state = handle_computer_game_events(mouse_pos)
                elif game_state == "GAME_OVER":
                    game_state = handle_game_over_events(mouse_pos)
                elif game_state == "RULES":
                    game_state = handle_rules_events(mouse_pos)
    ```
    
6. **Gestion spécifique de chaque état**:
    - Fonctions dédiées pour chaque état du jeu:
        - `handle_menu_events(mouse_pos)`
        - `handle_human_game_events(mouse_pos)`
        - `handle_computer_game_events(mouse_pos)`
        - `handle_game_over_events(mouse_pos)`
        - `handle_rules_events(mouse_pos)`
7. **Boucle de jeu principale**:
    
    python
    
    ```python
    def main():
        while True:
            handle_events()
            
            # Logique de jeu variable selon l'état
            if game_state == "GAME_VS_COMPUTER" and current_player == 2:
                handle_computer_turn()
            
            # Affichage selon l'état actuel
            if game_state == "MENU":
                display.draw_menu(screen)
            elif game_state in ["GAME_VS_HUMAN", "GAME_VS_COMPUTER"]:
                display.draw_board(screen, board)
                display.draw_game_info(screen, current_player, player_names, scores, game_state)
            elif game_state == "GAME_OVER":
                display.draw_board(screen, board)
                display.draw_game_over(screen, winner, winning_tokens, scores, player_names)
            elif game_state == "RULES":
                display.draw_rules(screen)
            
            pygame.display.flip()
            clock.tick(utils.FPS)
    ```
    
8. **Gestion du tour de l'ordinateur**:
    
    python
    
    ```python
    def handle_computer_turn():
        global current_player, last_token_pos, winning_tokens, game_state
        
        # Pause pour simuler une réflexion
        computer_player.simulate_thinking()
        
        # Obtention du coup de l'ordinateur
        column = computer_player.get_computer_move(board)
        
        # Placement du jeton
        if column is not None:
            last_token_pos = game_logic.place_token(board, column, current_player)
            
            # Vérification des conditions de victoire
            winning_tokens = game_logic.check_win(board, last_token_pos, current_player)
            if winning_tokens:
                scores["player2"] += 1
                winner = "player2"
                game_state = "GAME_OVER"
            elif game_logic.is_board_full(board):
                winner = None
                game_state = "GAME_OVER"
            else:
                current_player = game_logic.switch_player(current_player)
    ```
    
9. **Point d'entrée du programme**:
    
    python
    
    ```python
    if __name__ == "__main__":
        main()
    ```
    

### Points de vigilance

1. **Gestion des états**: Assurez-vous que les transitions entre les différents états du jeu sont fluides et cohérentes. Une erreur courante est d'avoir des états contradictoires ou des transitions manquantes.
2. **Traitement des événements**: Les événements Pygame doivent être traités à chaque itération de la boucle principale, sinon l'interface peut sembler bloquée ou ne pas répondre.
3. **Synchronisation**: Lorsque l'ordinateur joue, veillez à ce que l'affichage soit mis à jour entre sa "réflexion" et son action pour maintenir la fluidité visuelle.
4. **Performance**: La boucle principale doit être optimisée pour éviter les ralentissements. Évitez les calculs lourds ou les appels de fonctions coûteux dans cette boucle.
5. **Gestion de la mémoire**: Nettoyez les ressources inutiles, surtout lors du redémarrage d'une partie ou du retour au menu.
6. **Fermeture propre**: Assurez-vous que `pygame.quit()` est appelé lorsque le jeu se termine pour libérer correctement les ressources.
7. **Portabilité**: Utilisez des chemins relatifs pour les ressources afin que le jeu fonctionne sur différents systèmes.
8. **Variables globales**: Limitez leur utilisation et préférez passer des paramètres entre fonctions. Si nécessaire, déclarez-les avec `global` dans les fonctions qui les modifient.
