Les tests de fonctionnement constituent une étape cruciale dans le développement d'un jeu comme Puissance 4. Ils vous permettent de vérifier que chaque composant fonctionne correctement, isolément et en interaction avec les autres modules. Voici une approche détaillée pour mettre en place une stratégie de test efficace.

## 1. Pourquoi tester votre jeu ?

### 1.1 Importance des tests

Le développement d'un jeu, même relativement simple comme Puissance 4, implique de nombreux mécanismes qui doivent fonctionner harmonieusement ensemble. Les tests sont essentiels pour plusieurs raisons :

- **Détection précoce des erreurs** : Identifier et corriger les bugs dès leur apparition est beaucoup plus simple et moins coûteux en temps que de devoir les rechercher dans un système complet.
- **Validation du comportement attendu** : Confirmer que chaque fonction produit exactement les résultats escomptés.
- **Facilitation des modifications** : Les tests permettent de vérifier rapidement que des changements dans le code n'ont pas introduit d'effets secondaires indésirables.
- **Documentation vivante** : Les tests constituent une forme de documentation qui montre concrètement comment les différentes parties du code sont censées fonctionner.
- **Renforcement de la confiance** : Un code bien testé procure une assurance quant à sa fiabilité et sa robustesse.

### 1.2 Types de tests applicables

Pour un jeu de Puissance 4, plusieurs niveaux de tests sont pertinents :

- **Tests unitaires** : Vérification du comportement correct de chaque fonction isolément.
- **Tests d'intégration** : Vérification des interactions entre différents modules.
- **Tests fonctionnels** : Validation des fonctionnalités complètes du jeu du point de vue de l'utilisateur.
- **Tests de régression** : S'assurer que les nouvelles modifications n'ont pas cassé des fonctionnalités existantes.

## 2. Tests unitaires par module

### 2.1 Tests du module de logique (`game_logic.py`)

Ce module étant au cœur du fonctionnement du jeu, il est particulièrement important de le tester rigoureusement.

#### Fonctions à tester :

```python
def test_init_board():
    """Teste la création et l'initialisation du plateau."""
    board = game_logic.init_board()
    
    # Vérifier les dimensions du plateau
    assert board.shape == (utils.COLUMNS, utils.ROWS)
    
    # Vérifier que toutes les cases sont initialisées à 0
    assert (board == 0).all()
    
    print("Test init_board: OK")

def test_is_valid_move():
    """Teste la validation des coups."""
    board = game_logic.init_board()
    
    # Coup valide dans une colonne vide
    assert game_logic.is_valid_move(board, 3) == True
    
    # Coup invalide (hors limites)
    assert game_logic.is_valid_move(board, -1) == False
    assert game_logic.is_valid_move(board, 7) == False
    
    # Remplir une colonne et vérifier qu'elle devient invalide
    for i in range(utils.ROWS):
        game_logic.place_token(board, 2, 1)
    assert game_logic.is_valid_move(board, 2) == False
    
    print("Test is_valid_move: OK")

def test_place_token():
    """Teste le placement des jetons."""
    board = game_logic.init_board()
    
    # Placement normal
    pos = game_logic.place_token(board, 3, 1)
    assert pos == (3, 5)  # Doit tomber en bas de la colonne
    assert board[3][5] == 1
    
    # Placement par-dessus
    pos = game_logic.place_token(board, 3, 2)
    assert pos == (3, 4)  # Doit s'empiler
    assert board[3][4] == 2
    assert board[3][5] == 1  # Le jeton précédent reste en place
    
    # Placement dans une colonne pleine
    for i in range(utils.ROWS - 2):  # -2 car on a déjà placé 2 jetons
        game_logic.place_token(board, 3, 1)
    assert board[3][0] == 1  # La colonne est pleine
    assert game_logic.place_token(board, 3, 2) == None  # Doit retourner None
    
    print("Test place_token: OK")

def test_check_win():
    """Teste la détection des victoires."""
    board = game_logic.init_board()
    
    # Pas de victoire sur un plateau vide
    assert game_logic.check_win(board, (3, 5), 1) == None
    
    # Victoire horizontale
    board = game_logic.init_board()
    for col in range(4):
        game_logic.place_token(board, col, 1)
    winning_pos = game_logic.check_win(board, (3, 5), 1)
    assert winning_pos is not None
    assert len(winning_pos) == 4
    
    # Victoire verticale
    board = game_logic.init_board()
    for row in range(4):
        game_logic.place_token(board, 3, 1)
    winning_pos = game_logic.check_win(board, (3, 2), 1)
    assert winning_pos is not None
    assert len(winning_pos) == 4
    
    # Victoire diagonale descendante
    board = game_logic.init_board()
    for i in range(4):
        # Créer une configuration diagonale
        for j in range(i):
            game_logic.place_token(board, i, 2)  # Jetons de support
        game_logic.place_token(board, i, 1)  # Jetons alignés
    winning_pos = game_logic.check_win(board, (3, 3), 1)
    assert winning_pos is not None
    assert len(winning_pos) == 4
    
    # Victoire diagonale montante
    board = game_logic.init_board()
    for i in range(4):
        # Créer une configuration diagonale inverse
        for j in range(3 - i):
            game_logic.place_token(board, i, 2)  # Jetons de support
        game_logic.place_token(board, i, 1)  # Jetons alignés
    winning_pos = game_logic.check_win(board, (3, 2), 1)
    assert winning_pos is not None
    assert len(winning_pos) == 4
    
    print("Test check_win: OK")

def test_is_board_full():
    """Teste la détection de plateau plein."""
    board = game_logic.init_board()
    
    # Plateau vide
    assert game_logic.is_board_full(board) == False
    
    # Plateau partiellement rempli
    for col in range(3):
        for row in range(utils.ROWS):
            board[col][row] = 1
    assert game_logic.is_board_full(board) == False
    
    # Plateau complètement rempli
    for col in range(utils.COLUMNS):
        for row in range(utils.ROWS):
            board[col][row] = 1
    assert game_logic.is_board_full(board) == True
    
    print("Test is_board_full: OK")
```

### 2.2 Tests du module ordinateur (`computer_player.py`)

Les tests pour ce module doivent vérifier que l'ordinateur prend des décisions valides.

```python
def test_get_computer_move():
    """Teste la sélection de colonne par l'ordinateur."""
    # Plateau vide
    board = game_logic.init_board()
    column = computer_player.get_computer_move(board)
    assert 0 <= column < utils.COLUMNS
    assert game_logic.is_valid_move(board, column)
    
    # Plateau presque plein
    board = game_logic.init_board()
    for col in range(utils.COLUMNS):
        for row in range(utils.ROWS):
            if col != 3 or row != 0:  # Laisse une seule case vide
                board[col][row] = 1
    column = computer_player.get_computer_move(board)
    assert column == 3  # Seule colonne disponible
    
    # Plateau complètement plein
    board = game_logic.init_board()
    for col in range(utils.COLUMNS):
        for row in range(utils.ROWS):
            board[col][row] = 1
    column = computer_player.get_computer_move(board)
    assert column is None
    
    print("Test get_computer_move: OK")
```

### 2.3 Tests du module utilitaire (`utils.py`)

Les fonctions utilitaires doivent être testées pour garantir leur précision.

```python
def test_board_to_pixel():
    """Teste la conversion coordonnées plateau → pixels."""
    # Test de quelques conversions
    x, y = utils.board_to_pixel(0, 0)
    assert x == utils.CELL_SIZE // 2
    assert y == utils.CELL_SIZE // 2
    
    x, y = utils.board_to_pixel(3, 2)
    assert x == 3 * utils.CELL_SIZE + utils.CELL_SIZE // 2
    assert y == 2 * utils.CELL_SIZE + utils.CELL_SIZE // 2
    
    print("Test board_to_pixel: OK")

def test_pixel_to_column():
    """Teste la conversion pixels → colonne."""
    # Ajustement pour le décalage du plateau
    board_x = (utils.WINDOW_WIDTH - utils.BOARD_WIDTH) // 2
    
    # Clic au milieu de la première colonne
    column = utils.pixel_to_column(board_x + utils.CELL_SIZE // 2)
    assert column == 0
    
    # Clic au milieu de la quatrième colonne
    column = utils.pixel_to_column(board_x + 3 * utils.CELL_SIZE + utils.CELL_SIZE // 2)
    assert column == 3
    
    # Clic hors du plateau (à gauche)
    column = utils.pixel_to_column(board_x - 10)
    assert column == -1
    
    # Clic hors du plateau (à droite)
    column = utils.pixel_to_column(board_x + utils.BOARD_WIDTH + 10)
    assert column == -1
    
    print("Test pixel_to_column: OK")
```

## 3. Tests d'intégration

Ces tests vérifient que les différents modules fonctionnent correctement ensemble.

```python
def test_game_flow():
    """Teste le flux complet d'une partie."""
    # Initialisation
    board = game_logic.init_board()
    current_player = 1
    
    # Simulation d'une partie alternant les coups
    for i in range(10):  # Jouer 10 coups alternés
        # Joueur 1
        column = 3  # Colonne du milieu
        last_pos = game_logic.place_token(board, column, current_player)
        assert last_pos is not None
        
        # Vérification de victoire
        winning_tokens = game_logic.check_win(board, last_pos, current_player)
        if winning_tokens:
            print(f"Joueur {current_player} a gagné après {i+1} coups")
            break
            
        # Changement de joueur
        current_player = game_logic.switch_player(current_player)
        
        # Joueur 2 (ou ordinateur)
        if current_player == 2:
            column = computer_player.get_computer_move(board)
            last_pos = game_logic.place_token(board, column, current_player)
            assert last_pos is not None
            
            # Vérification de victoire
            winning_tokens = game_logic.check_win(board, last_pos, current_player)
            if winning_tokens:
                print(f"Joueur {current_player} a gagné après {i+1} coups")
                break
                
            # Changement de joueur
            current_player = game_logic.switch_player(current_player)
    
    print("Test game_flow: OK")
```

## 4. Tests de l'interface graphique

Les tests d'interface graphique sont plus difficiles à automatiser, mais on peut créer des tests manuels ou semi-automatisés.

```python
def test_display_init():
    """Teste l'initialisation de l'affichage."""
    # Initialisation de Pygame
    pygame.init()
    screen = pygame.display.set_mode((utils.WINDOW_WIDTH, utils.WINDOW_HEIGHT))
    
    # Vérifier que l'écran est créé avec les bonnes dimensions
    assert screen.get_width() == utils.WINDOW_WIDTH
    assert screen.get_height() == utils.WINDOW_HEIGHT
    
    # Charger et vérifier les ressources
    try:
        board_img = pygame.image.load(utils.resource_path("assets/board.png"))
        red_token_img = pygame.image.load(utils.resource_path("assets/red_token.png"))
        yellow_token_img = pygame.image.load(utils.resource_path("assets/yellow_token.png"))
        assert board_img is not None
        assert red_token_img is not None
        assert yellow_token_img is not None
        print("Test display_init: OK")
    except Exception as e:
        print(f"Test display_init: ÉCHEC - {e}")
    finally:
        pygame.quit()
```

## 5. Tests fonctionnels manuels

Pour certains aspects de votre jeu, des tests manuels seront nécessaires. Voici une liste de vérifications à effectuer :

1. **Test du menu principal** :
    
    - Les boutons sont-ils tous visibles et cliquables ?
    - La navigation entre les écrans fonctionne-t-elle correctement ?
    - Le bouton "Quitter" ferme-t-il proprement l'application ?
2. **Test du mode deux joueurs** :
    
    - Les joueurs peuvent-ils placer des jetons à tour de rôle ?
    - L'indication du joueur actif est-elle mise à jour correctement ?
    - La détection des victoires fonctionne-t-elle dans toutes les directions ?
    - Le compteur de score s'incrémente-t-il correctement ?
3. **Test du mode contre l'ordinateur** :
    
    - L'ordinateur joue-t-il après chaque coup du joueur ?
    - L'ordinateur ne place-t-il des jetons que dans des colonnes valides ?
    - Le délai de "réflexion" de l'ordinateur est-il approprié ?
4. **Test de l'écran de fin de partie** :
    
    - L'annonce du résultat est-elle correcte (victoire ou match nul) ?
    - L'alignement gagnant est-il bien mis en évidence ?
    - Les boutons "Rejouer" et "Menu principal" fonctionnent-ils ?
5. **Test de l'aide** :
    
    - Le bouton d'aide est-il accessible à tout moment ?
    - Les règles du jeu sont-elles clairement expliquées ?
    - Le retour au jeu fonctionne-t-il correctement ?

## 6. Organisation et exécution des tests

### 6.1 Structure du module de test

Pour organiser vos tests de manière claire et efficace, créez un fichier `tests.py` dans votre projet :

```python
import pygame
import numpy as np
import sys
import time

# Importation des modules du jeu
import game_logic
import display
import computer_player
import utils

# Fonction principale pour exécuter tous les tests
def run_all_tests():
    # Tests unitaires
    print("\n=== Tests unitaires ===")
    print("\n-- Module game_logic --")
    test_init_board()
    test_is_valid_move()
    test_place_token()
    test_check_win()
    test_is_board_full()
    
    print("\n-- Module computer_player --")
    test_get_computer_move()
    
    print("\n-- Module utils --")
    test_board_to_pixel()
    test_pixel_to_column()
    
    # Tests d'intégration
    print("\n=== Tests d'intégration ===")
    test_game_flow()
    
    # Tests d'interface
    print("\n=== Tests d'interface ===")
    test_display_init()
    
    print("\n=== Tous les tests automatisés sont terminés ===")
    print("N'oubliez pas d'effectuer les tests manuels listés dans la documentation.")

# Point d'entrée
if __name__ == "__main__":
    run_all_tests()
```

### 6.2 Exécution des tests

Pour exécuter vos tests :

1. Créez le fichier `tests.py` avec toutes les fonctions de test décrites précédemment.
2. Exécutez le script avec la commande : `python tests.py`
3. Observez les résultats dans la console et corrigez les éventuelles erreurs.

### 6.3 Points de vigilance pour les tests

1. **Isolation des tests** : Chaque test doit être indépendant des autres pour éviter que l'échec d'un test n'affecte les suivants.
2. **Couverture complète** : Essayez de tester tous les cas possibles, y compris les cas limites et les situations d'erreur.
3. **Tests réguliers** : Exécutez les tests après chaque modification significative du code.
4. **Documentation des erreurs** : Documentez tous les bugs découverts et leur solution pour référence future.
5. **Tests réalistes** : Assurez-vous que vos tests représentent fidèlement l'utilisation réelle du jeu.

## 7. Conclusion

Les tests sont une étape fondamentale dans le développement d'un jeu robuste et agréable à utiliser. En mettant en place une stratégie de test complète pour votre jeu de Puissance 4, vous vous assurez que :

- Chaque composant fonctionne correctement de manière isolée
- Les interactions entre les différents modules sont cohérentes
- L'expérience utilisateur répond aux attentes
- Les modifications futures pourront être intégrées avec confiance

Cette approche méthodique des tests vous permettra de livrer un jeu de qualité et vous fera gagner du temps sur le long terme en réduisant le nombre de bugs à corriger après le développement initial.